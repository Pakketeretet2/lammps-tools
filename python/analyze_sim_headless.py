import gen_morphexpt as gm
import numpy as np
import scipy
import sys
import os, glob
import re
import skeleton_tools as skt
import cPickle as pickle
import networkx as nx

argc = len(sys.argv)
if( argc < 1 ):
    print "You need to set the file to parse!"
    sys.exit(-1);


if( argc <= 2 ):
    drop_radius = None
else:
    drop_radius = float(sys.argv[2])


ptfile = sys.argv[1]
print "file to parse:", ptfile

# load the original point data, from a file with three columns depicting x,y,z coordinates of points# points are assumed to have diameter of 1
pts = np.loadtxt(ptfile)
print type(pts), type(pts[0]), type(pts[0,0])

# convert into a MorphExpt object, which merges the points into a continous solid
# and performs various morphological operations that can be used to extract
# the average width etc.

me = gm.gen_morphexpt(pts,1.0, 0.3, 8, drop_radius, np.array([0,0,0]))

# this plot shows the gridded data generated by the morphology.
# each point is coloured by its distance from the closest edge of the domain.

# plot the approximation to the morphological skeleton of the domain

# Each skeleton is a list of points that traces out the path in 3D, and a list of distances
# of those points from the domain edge. The example file has just one contiguous domain and
# thus just one skeleton



# some useful data, from the MorphExpt object
print "Radius of underlying droplet, obtained by fitting:", me.droplet[3]
print "Diameter of largest possible inscribed circle:", 2*np.max(me.sphere_distance())

# get the length of the longest piece of the backbone. see the skeleton_tools functions docs for more details.

gg = skt.skel_min_graph_real(me.skeletons[0],me.ptc_dia)
bb = skt.backbone(gg)
print "Length of backbone spine:", skt.skel_length(bb)

