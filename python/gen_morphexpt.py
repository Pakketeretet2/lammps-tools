import numpy as np
import scipy
from copy import copy
from scipy import ndimage
import scipy.ndimage.morphology as morphology
import skeleton_tools as skt
import sys

def skel_by_erode(arr):
    b = morphology.generate_binary_structure(len(arr.shape),1)
    y = np.zeros(arr.shape)
    for r in xrange(1,20):
        nb = morphology.iterate_structure(b, r)
        ero = morphology.binary_erosion(arr, nb)
        if sum(ero) == 0: break
        #~ f1 = morphology.white_tophat(ero,structure=b)
        f1 = ero - morphology.binary_opening(ero,structure=b)
        y = y + f1*r
    return y
    
def skel_by_erode_z(arr):
    b2 = morphology.generate_binary_structure(len(arr.shape),1)
    b = np.zeros_like(b2)
    b[1,1,:]=1
    y = np.zeros(arr.shape)
    for r in xrange(1,20):
        #~ print "r : ", r
        nb = morphology.iterate_structure(b, r)
        ero = morphology.binary_erosion(arr, nb)
        if np.sum(ero) == 0: break
        #~ f1 = morphology.white_tophat(ero,structure=b)
        f1 = ero - morphology.binary_opening(ero,structure=b)
        y = y + f1*r
    return y


def erosion_droplet(arr):
    """
    given a binary sphere, does a droplet fitting of the points denoting 
    a shape (i.e. arr == 1) b.meta.t using z-axis erosion to prevent the thickness
    of the domain from throwing off the fit
    """
    arr = np.array(arr,dtype='bool')
    sk = skel_by_erode_z(arr)
    nsks = [np.sum(sk==p) for p in np.arange(np.max(sk))]
    nsks[0] = 0
    midlayer = np.transpose(np.where(sk==np.argmax(nsks)))*1.
    dropletmid = skt.droplet_fitting(midlayer)
    return dropletmid

def fit_radii(coords,droplet):
    coords = coords - droplet[:3]
    return droplet, np.sqrt(np.sum(coords**2,axis=1))

def binarysphere(blocks,drp=None,radius_threshold=0.3,resolution_scale=8.,drop_radius=None,drop_pos=np.array( [0,0,0]) ):
    #~ pp = np.where(blocks)
    #~ pp = np.transpose(pp)
    #~ drp = analysis.droplet_fitting(pp)
    if drp is None: drp = erosion_droplet(blocks)
    rad = drp[3]
    
    gz = np.zeros(blocks.shape,dtype = bool)
    allp = np.transpose(np.where(gz < 1))
    
    if drop_radius is None:
        print >> sys.stderr, "gen_morphexpt.py, 66: Fitting droplet!"
        drp, rads = fit_radii(allp,drp)
    else:
        print >> sys.stderr, "Drop radius is ", drop_radius
        drp  = np.array([0,0,0,drop_radius], dtype = np.float64)
        rads = drop_radius
        
    #~ return rads
    shell = np.array(allp[(rads > (rad+radius_threshold*resolution_scale)) | (rads < (rad-radius_threshold*resolution_scale))],dtype=int)
    
    shell = tuple(shell.transpose())
    gz[shell] = 1
    return gz

    
def cubify(stack, pixels):
    diameter = ptc_dia/pixels

    grzoom = scipy.ndimage.interpolation.zoom(stack, tuple(pixels*resolution_scale),output = int) # scale to three times natural size -- i.e. a cube with three pi
    return grzoom

def binarify(arr):
    arr[np.where(arr > 0)] = 1
    return np.array(arr, dtype='bool')
    
def toPoints(arr):
    return np.transpose(np.where(arr));
    
# visualization helpers
def get_central_vectors(pts):
    drp = analysis.droplet_fitting(pts)
    pts = pts-drp[:3]
    u,v,w = pts.T
    return u,v,w
    

class MorphExpt:
    """
    Container of morphological data for saving results to disk.
    saves results in real, not lattice, units
    """
    def __init__(self,ptc_dia=1.):
        self.ptc_dia = ptc_dia
        
    def sphere_distance(self):
        """
        Return a 1D array of same length as grid_domain_pts, with
        distance along the sphere from each point to boundary
        """
        radius = self.droplet[3]
        distance = self.grid_distance
        return 2*radius*np.arcsin(distance/2./radius)


def centroid_mask(diameter = None):
    if diameter is None:
        diameter = np.array((5, 5, 5))
    # setup the single particle mask.
    offset = np.mod(np.ceil(diameter)+1., 2.)
    w = np.array(diameter + offset, dtype=int)/2

    # matrix array to setup masks.
    [x, y, z] = np.mgrid[-w[0]:w[0]+1.,-w[1]:w[1]+1.,-w[2]:w[2]+1.]
    # make up distance matrix and centroid mask
    # act_distance to determine the centroid mask
    act_distance=np.array((x/diameter[0])**2+(y/diameter[1])**2+(z/diameter[2])**2)
    # centroid_mask will be used in filtering data and finding features.
    c = np.array(act_distance<0.25, dtype=np.int32)
    return c

def gen_morphexpt(pts,ptc_dia = 1., radius_threshold=0.3, resolution_scale=8.,drop_radius=None,drop_pos=np.array([0,0,0]) ):
    """ generate a fake experimental closed data from simulation output
    pts: Nx3 array of 3D point data of N points
    ptc_dia: particle diameter of hard spheres whose centers are provided in pts
    radius_threshold: thickness of the contiguous domain generated by this function (in the radial direction of the droplet)
    resolution_scale: grid resolution, in points per length unit, of the contiguous domain generated by this function.  
    """
    # padding = 5 # microns added around pts
    padding = 0.3
    x,y,z = pts.T
    delx = np.max(x)-np.min(x)
    dely = np.max(y)-np.min(y)
    delz = np.max(z)-np.min(z)
    shiftd = np.array([-np.min(x)+padding/2.,-np.min(y)+padding/2.,-np.min(z)+padding/2.])
    pts = pts + shiftd
    
    blocks = np.zeros((int((delx+padding)*resolution_scale),int((dely+padding)*resolution_scale),int((delz+padding)*resolution_scale)),dtype=bool)
    #~ print blocks.shape
    
    # fill in best approximation of point centres
    for x,y,z in pts:
        blocks[int(x*resolution_scale),int(y*resolution_scale),int(z*resolution_scale)] = True

    if drop_radius is None:
        print >> sys.stderr, "gen_morphexpt, drop_radius = ", drop_radius
        tmp = np.transpose(np.where(blocks))
        droplet = skt.droplet_fitting(np.transpose(np.where(blocks)))
    else:
        print >> sys.stderr, "gen_morphexpt, drop_radius = ", drop_radius
    	droplet = np.empty(4,dtype=np.float64)
        droplet[0] = drop_pos[0]
        droplet[1] = drop_pos[1]
        droplet[2] = drop_pos[2]
        droplet[3] = drop_radius

        # Add the stupid weird offset as well:
        droplet[0:3] += shiftd
        droplet *= resolution_scale
        # Don't put this to zero, WTF?!
        # drop_radius = None
    
    # create spherical dilation mask
    mask_size = int(ptc_dia*resolution_scale)
    sphmask = centroid_mask(np.array([mask_size*1.1,mask_size*1.1,mask_size*1.1]))
    
    
    # dilate to get particles at these centres
    blocks = morphology.binary_dilation(blocks,structure=sphmask)
    
    # grey_closing to fill gaps
    blocks = morphology.grey_closing(blocks, footprint=sphmask)
    print >> sys.stderr, "gen_morphexpt.py, 186: drop_radius = ", drop_radius
    grid_sphere = binarysphere(blocks,droplet,radius_threshold=radius_threshold,resolution_scale=resolution_scale,drop_radius=drop_radius, drop_pos=droplet[:3])
        
    grid_points_sphere = binarify(blocks+grid_sphere)
    grid_domains = grid_points_sphere - grid_sphere
    grid_domain_idx = np.where(grid_domains)
    
    
    eucb = scipy.ndimage.distance_transform_edt(grid_points_sphere)
    grid_distance = eucb[grid_domain_idx]
    
    domain_pts = np.transpose(np.where(grid_domains))/resolution_scale
    
    newexpt = MorphExpt()
    newexpt.ptc_dia = ptc_dia # particle diameter
    newexpt.radius_threshold = radius_threshold # radius range in real coordinates 
    newexpt.resolution_scale = resolution_scale # scale of the binary array, equal to number of points in grid per micron

    newexpt.pixelsize = (1./resolution_scale,1./resolution_scale,1./resolution_scale)
    if not isinstance(droplet,np.ndarray):
        droplet = np.array( droplet, dtype=np.float64 )
    newexpt.droplet = droplet/resolution_scale
    newexpt.grid_distance = grid_distance/resolution_scale
    newexpt.domain_pts = domain_pts
    
    skels = skt.get_skeletons(eucb,grid_domains,newexpt.resolution_scale,ptc_dia,drp=droplet)
    radius = droplet[3]/resolution_scale
    newskels = []
    for respts,rds in skels:
        newpts = respts/resolution_scale
        distance = rds/resolution_scale
        sphereds = 2*radius*np.arcsin(distance/2./radius)
        newskels.append((newpts,sphereds))
    newexpt.skeletons = tuple(newskels)
    
    return newexpt
    
    
    
    
